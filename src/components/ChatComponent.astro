---
---
<script is:inline>
 const globalMenuPortal = document.createElement('div');
globalMenuPortal.className = 'menu-portal';
Object.assign(globalMenuPortal.style, {
    position: 'absolute',
    zIndex: '10',
    display: 'none',
    pointerEvents: 'none',
});
globalMenuPortal.innerHTML = `
  <style>
    .menu-options {
      position: absolute;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      min-width: 120px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      pointer-events: auto;
    }
    .menu-option {
      padding: 8px 12px;
      cursor: pointer;
      background: none;
      border: none;
      text-align: left;
      width: 100%;
      font-family: inherit;
      font-size: 14px;
      color: #333;
    }
    .menu-option:hover {
      background-color: #f0f0f0;
    }
  </style>
  <div class="menu-options" role="menu"></div>
`;
function getRandomColor(string) {
    let randomChar = string || Math.random().toString(36).substring(2, 15);
    return getColorByChar(randomChar);
    //return '#' + Math.floor(Math.random()*16777215).toString(16);
}
function getColorByChar(char) {
    const alphabet = 'abcdefghijklmnopqrstuvwxyz';

    // Asignar un índice único para cada carácter del alfabeto
    const lowerChar = char.toLowerCase();
    const index = alphabet.indexOf(lowerChar);

    // Si no es un carácter alfabético, devuelve un color por defecto
    if (index === -1) return '#ff5733'; // Ejemplo de color por defecto

    // Convertir índice a un color HSL saturado y con luminosidad moderada
    const hue = (index / alphabet.length) * 360; // Distribuir colores uniformemente en el espectro
    const saturation = 85; // Alta saturación
    const lightness = 45; // Moderada luminosidad para evitar tonos muy claros o muy oscuros

    // Convertir HSL a HEX
    return hslToHex(hue, saturation, lightness);
}

// Función para convertir HSL a HEX
function hslToHex(h, s, l) {
    s /= 100;
    l /= 100;

    let c = (1 - Math.abs(2 * l - 1)) * s;
    let x = c * (1 - Math.abs((h / 60) % 2 - 1));
    let m = l - c / 2;
    let r = 0, g = 0, b = 0;

    if (0 <= h && h < 60) { r = c; g = x; b = 0; }
    else if (60 <= h && h < 120) { r = x; g = c; b = 0; }
    else if (120 <= h && h < 180) { r = 0; g = c; b = x; }
    else if (180 <= h && h < 240) { r = 0; g = x; b = c; }
    else if (240 <= h && h < 300) { r = x; g = 0; b = c; }
    else if (300 <= h && h < 360) { r = c; g = 0; b = x; }

    r = Math.round((r + m) * 255);
    g = Math.round((g + m) * 255);
    b = Math.round((b + m) * 255);

    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
}
class MessageContainer extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        this.shadowRoot.innerHTML = `
        <style>
          :host {
            display: block;
            width: 100%;
            height: 100%;
            position: relative;
            resize: both;
            overflow: hidden;
          }
          .messages-wrapper {
            position: relative;
            min-height: 100%;
            max-height: 280px;
            overflow-y: auto;
          }
          .maxh-5rem {max-height: 5rem !important;}
          .maxh-10rem {max-height: 10rem !important;}
          .maxh-15rem {max-height: 15rem !important;}
          .maxh-20rem {max-height: 20rem !important;}
          .maxh-25rem {max-height: 25rem !important;}
          .maxh-30rem {max-height: 30rem !important;}
        </style>
        <div class="messages-wrapper" id="messagesWrapper">
          <slot></slot>
        </div>
      `;

        this.messagesWrapper = this.shadowRoot.querySelector('#messagesWrapper');
    }

    connectedCallback() {
        // Aplicar clases desde un atributo
        if (this.hasAttribute('wrapper-classes')) {
            this.messagesWrapper.className += ` ${this.getAttribute('wrapper-classes')}`;
        }

        // Aplicar estilo dinámico desde un atributo
        if (this.hasAttribute('wrapper-style')) {
            this.messagesWrapper.style.cssText += this.getAttribute('wrapper-style');
        }

        // Observador para detectar cambios en el contenedor principal
        if (this.messagesWrapper) {
            const observer = new MutationObserver(() => {
                this.scrollToBottom();
            });
            observer.observe(this.messagesWrapper, { childList: true });
        }
    }

    addMessage(messageData, autoHide = false) {
        const message = document.createElement('chat-message');

        message.setMessageData(messageData);
        this.messagesWrapper.appendChild(message);
        this.scrollToBottom();
        if (autoHide) message.setAutoHide(3000);
    }

    scrollToBottom() {
        this.messagesWrapper.scrollTop = this.messagesWrapper.scrollHeight;
    }
}
class ChatMessage extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        this._menuOptions = [];
        this._menuPortal = globalMenuPortal; // Usar el menuPortal global
        this._currentMessageData = null; // Almacena los datos del mensaje actual
    }

    connectedCallback() {
        document.addEventListener('click', this._handleClickOutside.bind(this));
    }

    disconnectedCallback() {
        document.removeEventListener('click', this._handleClickOutside);
    }
    _handleClickOutside(event) {
        if (!this._menuPortal.contains(event.target) &&
            !this.shadowRoot.querySelector('.menu-button').contains(event.target)) {
            this._hideMenu();
        }
    }
    setMessageData(data) {
        const { user, content, menu } = data;
        this._data = { user, content };
        this._menuOptions = menu?.options || [];
        this.renderMessage(user, content);
        this.setupMenu();
    }

    renderMessage(user, content) {
        const bgColor = user.photo ? '' : this.getRandomColor();
        const initial = user.photo ? '' : user.name.charAt(0).toUpperCase();

        this.shadowRoot.innerHTML = `
        <style>
          :host {
            display: flex;
            margin-bottom: 10px;
            position: relative;
          }
          img {
            max-width: 100%;
            max-height: 250px;
            height: auto;
            width: auto;
            display: block;
            margin-bottom: 5px;
          }
          .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            flex-shrink: 0;
          }
          .message-content {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            margin-right: 30px;
            gap: 0;
          }
          p {
            margin: 0;
            padding: 0;
          }
          .menu-button {
            position: absolute;
            right: 0;
            top: 0;
            cursor: pointer;
            padding: 5px;
            background: none;
            border: none;
            font-size: 16px;
            color: #666;
            transition: color 0.2s;
          }
          .menu-button:hover {
            color: #333;
          }
        </style>
        <div class="avatar" role="img" aria-label="User avatar">${initial}</div>
        <div class="message-content"></div>
        <button class="menu-button" role="button" aria-haspopup="true" aria-expanded="false">⋮</button>
      `;

        const avatar = this.shadowRoot.querySelector('.avatar');
        if (user.photo) {
            avatar.style.backgroundImage = `url(${user.photo})`;
            avatar.style.backgroundSize = 'cover';
        } else {
            avatar.style.backgroundColor = bgColor;
        }

        const messageContent = this.shadowRoot.querySelector('.message-content');
        content.forEach(item => {
            const messageItem = document.createElement('div');
            const classNameItem = item.class || 'message-item';
            messageItem.className = classNameItem;

            if (item.type === 'image') {
                const img = document.createElement('img');
                img.src = item.value;
                img.alt = 'message image';
                messageItem.appendChild(img);
            }

            if (item.type === 'text') {
                const p = document.createElement('p');
                p.textContent = item.value;
                p.className = `message-text ${classNameItem}`;
                messageItem.appendChild(p);
            }

            if (item.type === 'url') {
                const a = document.createElement('a');
                a.href = item.url;
                a.textContent = item.value;
                a.className = `message-text ${classNameItem}`;
                messageItem.appendChild(a);
            }

            messageContent.appendChild(messageItem);
        });
    }

    setupMenu() {
        const menuButton = this.shadowRoot.querySelector('.menu-button');
        const menuOptions = this._menuPortal.querySelector('.menu-options');

        menuButton.addEventListener('click', (event) => {
            event.stopPropagation();
            this._currentMessageData = this.getMessageData();
            this._updateMenuOptions();
            const isExpanded = menuButton.getAttribute('aria-expanded') === 'true';
            isExpanded ? this._hideMenu() : this._showMenu();
        });
    }

    _updateMenuOptions() {
        const menuOptions = this._menuPortal.querySelector('.menu-options');

        // Eliminar listeners de los elementos existentes
        [...menuOptions.children].forEach(child => {
            const oldListeners = child._listeners || [];
            oldListeners.forEach(([event, handler]) => {
                child.removeEventListener(event, handler);
            });
        });

        // Vaciar el contenedor
        menuOptions.innerHTML = '';

        // Crear nuevos botones con sus eventos
        this._menuOptions.forEach(option => {
            if (typeof option.callback === 'function') {
                const button = document.createElement('button');
                button.textContent = option.text;
                button.classList.add('menu-option');
                button.setAttribute('role', 'menuitem');

                // Asociar el evento y guardar referencia
                const clickHandler = (e) => {
                    e.stopPropagation();
                    option.callback(this._currentMessageData);
                    this._hideMenu();
                };
                button.addEventListener('click', clickHandler);
                button._listeners = [['click', clickHandler]];

                menuOptions.appendChild(button);
            }
        });
    }


    _showMenu() {
        const menuButton = this.shadowRoot.querySelector('.menu-button');
        menuButton.setAttribute('aria-expanded', 'true');
        this._menuPortal.style.display = 'block';
        this._updateMenuPosition();
    }

    _hideMenu() {
        const menuButton = this.shadowRoot.querySelector('.menu-button');
        menuButton.setAttribute('aria-expanded', 'false');
        this._menuPortal.style.display = 'none';
    }

    _updateMenuPosition() {
        const buttonRect = this.shadowRoot.querySelector('.menu-button').getBoundingClientRect();
        Object.assign(this._menuPortal.style, {
            top: `${buttonRect.bottom}px`,
            left: `${buttonRect.left}px`,
        });
    }

    getMessageData() {
        return this._data;
    }

    getRandomColor() {
        const colors = ['#4CAF50', '#2196F3', '#9C27B0', '#F44336', '#FF9800'];
        return colors[Math.floor(Math.random() * colors.length)];
    }
    hide() {
        this.style.display = 'none';
    }

    // Method to remove the message from the DOM
    remove() {
        this.parentNode.removeChild(this);
    }
    setAutoHide(timeout) {
        // tiempo de espera antes de que se borre este elemento
        this._autoHideTimeout = timeout;
        setTimeout(() => {
            this.remove();
        }, timeout);
    }
}
if (!customElements.get('chat-message')) {
customElements.define('chat-message', ChatMessage);
}
if (!customElements.get('message-container')) {
customElements.define('message-container', MessageContainer);
}

</script>
<div  id="chat-container" class="chat1 chatcontainer">
  <message-container id="chatcontainer" wrapper-classes="maxh-20rem"></message-container>
</div>
<div class="gift2 giftcontainer">
  <message-container id="giftcontainer" wrapper-classes="maxh-20rem"></message-container>
</div>
<div class="events3 eventscontainer">
  <message-container id="eventscontainer" wrapper-classes="maxh-10rem"></message-container>
</div>
<script type="module">
import { webcomponentevent, appendMessage, handlechat, handlegift, mapEvent, arrayevents,lastElement } from '/src/utils/chat.js';
import { Emitter, TiktokEmitter, socket } from '/src/socket/socketmanager.js';
TiktokEmitter.on('chat', async (data) => {
  console.log("TiktokEmitter",data);
  handlechat(data);
});
TiktokEmitter.on('gift', async (data) => {
  console.log("TiktokEmitter",data);
  handlegift(data);
});

lastElement();
</script>